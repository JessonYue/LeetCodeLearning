# Linux信号（signal) 机制

signal，又简称为信号（软中断信号）用来通知进程发生了异步事件

原理：
     一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的**异步通信机制**，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，**通知进程**发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。



**分类：**

从两个不同的分类角度对信号进行：

可靠性方面：可靠信号与不可靠信号；

与时间的关系上：实时信号与非实时信号



---

# Linux信号量（semaphore）机制

Linux内核的信号量用来操作系统进程间**同步访问共享资源**

  **原理：**

- 信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有**一个任务可以访问信号量保护的共享资源**
- 一个任务要**想访问共享资源**，首先**必须得到信号量**，获取信号量的操作将把信号量的值减1，若当前信号量的值为**负数**，表明**无法获得信号量**，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源
- 当**任务访问完被信号量保护的共享资源**后，必须**释放信号量**，**释放信号量通过把信号量的值加1**实现，如果**信号量的值为非正数**，表明有任务**等待当前信号量**，因此它也**唤醒所有等待该信号量的任务**



```
DECLARE_MUTEX(name)   //宏声明一个信号量name并初始化它的值为0，即声明一个互斥锁
```

```
DECLARE_MUTEX_LOCKED(name)  //宏声明一个互斥锁name，但把它的初始值设置为0，即锁在创建时就处在已锁状								//态。因此对于这种锁，一般是先释放后获得
```

```
void sema_init (struct semaphore *sem, int val); //用于数初始化设置信号量的初值，它设置信号量sem的													//值为val
```

```
void init_MUTEX (struct semaphore *sem); //初始化一个互斥锁，即它把信号量sem的值设置为1
```

```
void init_MUTEX_LOCKED (struct semaphore *sem); //初始化一个互斥锁，但它把信号量sem的值设置为0，即												//一开始就处在已锁状态
```

```
void down(struct semaphore * sem);  //获得信号量sem，它会导致睡眠，因此不能在中断上下文（包括IRQ上下文和softirq上下文）使用该函数。该函数将把sem的值减1，如果信号量sem的值非负，就直接返回，否则调用者将被挂起，直到别的任务释放该信号量才能继续运行。
```

```
int down_interruptible(struct semaphore * sem); //与down类似，不同之处为，down不会被信号（signal）打断，但down_interruptible能被信号打断，因此该函数有返回值来区分是正常返回还是被信号中断，如果返回0，表示获得信号量正常返回，如果被信号打断，返回-EINTR
```

```
int down_trylock(struct semaphore * sem);//试着获得信号量sem，如果能够立刻获得，它就获得该信号量并返回0，否则，表示不能获得信号量sem，返回值为非0值。因此，它不会导致调用者睡眠，可以在中断上下文使用
```

```
void up(struct semaphore * sem);//放信号量sem，即把sem的值加1，如果sem的值为非正数，表明有任务等待该								//信号量，因此唤醒这些等待者
```

**信号量在绝大部分情况下作为互斥锁使用**