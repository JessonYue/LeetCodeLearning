题目：

```
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？
```

心路历程

```
维护一个N+1（可以获取到倒数N+1个节点）长度的数组，然后遍历获取到链表的长度，最后 倒数N+1个节点.next = 倒数N-1个节点
```

代码

```
public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null){
            return null;
        }
        
        //维护N+1个节点的数组
        int m = n+1;
        ListNode[] nodes = new ListNode[m];

        ListNode current = head;
        ListNode pre = head;//需要返回的节点
        int length = 0;//链表的长度
        while(current != null){
            nodes[length%m] = current;//往数组中添加节点，位置为length % m; 
            current = current.next;
            length++;
        }

				//优化边界值
        if(length == n){
            return head.next;
        }
				
				//倒数N+1个节点.next = 倒数N个节点.next
        nodes[(length-m) % m].next = nodes[(length-n) % m].next;
        
        return pre;
    }
```