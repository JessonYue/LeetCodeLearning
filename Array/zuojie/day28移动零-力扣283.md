#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)



给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

#### 方法一：空间最优，操作局部优化（双指针）

我们创建两个指针`i`和`j`，第一次遍历的时候指针`j`用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，`j`指针的下标就指向了最后一个非0元素下标。
第二次遍历的时候，起始位置就从`j`开始到结束，将剩下的这段区域内的元素全

动画演示（a = i,b =j）：

![](https://pic.leetcode-cn.com/9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int length = nums.length;
        int j = 0;
        for (int i = 0; i < length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        for (int i = j; i < length; i++) {
            nums[i] = 0;
        }
    }
}
```



**复杂度分析**

- 时间复杂度： O(n)。但是，操作仍然是局部优化的。代码执行的总操作（数组写入）为  n（元素总数）。
- 空间复杂度： O(1)，只使用常量空间。

#### 方法二：一次遍历

这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点`x`，然后把所有小于等于x的元素放到`x`的左边，大于`x`的元素放到其右边。
这里我们可以用`0`当做这个中间点，把不等于`0`(注意题目没说不能有负数)的放到中间点的左边，等于`0`的放到其右边。
这的中间点就是`0`本身，所以实现起来比快速排序简单很多，我们使用两个指针`i`和`j`，只要`nums[i]!=0`，我们就交换`nums[i]`和`nums[j]`



![](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)



```java
class Solution {
    public void moveZeroes(int[] nums) {
        int length = nums.length;
        for (int j = 0, i = 0; i < length; i++) {
            if (nums[i] != 0) {
                int temp = nums[i];
                nums[i]  = nums[j];
                nums[j++] = temp;
            }
        }
    }
}
```

**复杂度分析**

- 时间复杂度： O(n)。但是，操作是最优的。代码执行的总操作（数组写入）是非 0 元素的数量。这比上一个解决方案的复杂性（当大多数元素为 0 时）要好得多。但是，两种算法的最坏情况（当所有元素都为非 0 时）复杂性是相同的。
- 空间复杂度： O(1)，只使用了常量空间。

