#### [565. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/)

索引从`0`开始长度为`N`的数组`A`，包含0到`N - 1`的所有整数。找到最大的集合S并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`且遵守以下的规则。

假设选择索引为i的元素`A[i]`为`S`的第一个元素，`S`的下一个元素应该是`A[A[i]]`，之后是`A[A[A[i]]]`... 以此类推，不断添加直到S出现重复的元素。

 示例 1:

```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```



**提示：**

1. `N`是`[1, 20,000]`之间的整数。
2. `A`中不含有重复的元素。
3. `A`中的元素大小在`[0, N-1]`之间。

### 解题思路

n长度的数组中包含0-n-1的不重复数字，取出一个数字以当前数字作为下一个数字的下标，可以看出按此逻辑取出的数字最终会构成一个圆环，剩下的数字也如此能构成圆环，找最长的序列，就是找最大的圆环。
因此，题目可以转换为，一个图中存在一个或多个圆环，求其中最大的圆环长度。
操作：

1. 以原数组为集合A,B为空集合；
2. 按题目逻辑取A中的数放入B中；
3. 必然会发生，A中没有下一个要取的数（此数已在B中），此时B中数字构成一个圆环;
4. 记录其size，清空集合B,继续从第2步开始，直到A中已经没有元素；
5. 记录的size中的最大值，即为题目所求

### 代码

```java
class Solution {
    public int arrayNesting(int[] nums) {
        int maxSize = 0;
        // 取数组中为使用的元素开始寻找环
        for(int i=0;i<nums.length;i++){
            // 被使用过的元素直接忽略
            if(nums[i]==-1){
                continue;
            }
            int index = i;
            int size = 0;
            // 取的下一数字已为-1，即A中已经没当前环的下继，可以结束寻找下一环
            while(nums[index]!=-1){
                // 集合B的size记录
                size++;
                // 取出当前数字
                int tmp = nums[index];
                // 取出的数字标记为-1
                nums[index] = -1;
                // 下一数字下标为当前数字值
                index = tmp;
            }
            // 记录最大环
            maxSize = Math.max(size,maxSize);
        }
        return maxSize;
    }
}
```

