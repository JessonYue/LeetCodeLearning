

## 0601求两数之和

使用最基础的解法。耗时较多，需要参考最优解



## 0602爬梯子

解题思路：

1阶：1

2:阶：2

3阶：2阶+1阶

4阶：3阶+2阶

5阶：4阶+3阶

……

总之后面产生的数时前2个数的和 f(n)=f(n-1)+f(n-2)

选择了最简单的递归，许多计算步骤有重复

## 0603字串

解题思路

1、先找到第一个匹配的字符

2、拿着匹配的字符，开始循环匹配后面的子串



## 0604合并有序数组

已经条件是两个数组已经排序并且A多余的长度足够容纳B

思路：

1、B中的数据直接扔到A，然后排序

2、利用A多余的空间，将A B数据对比着从后面放入

3、造一个数组，将A和B对比然后扔到新数组里面



## 0605补充链表交集

判断两个链表是否相交解题思路：

1、只要将两个链表长度都弄成一样的，如果最后一段 [不是一个] 节点有相等部分切不为null，就说明两个链表有交集

##  0608反转

反转链表  

- 解题思路1：使用迭代  
  1、保留一份next元素的的引用，保留一份pre元素的引用  
  2、遍历的时候将pre赋值给当前元素的next，然后将pre移动到当前元素的位置  

- 解题思路2：使用递归  
  1、递归有个特点就是出口位置才能确定计算的值、数据、方向等  
  2、由于链表不知长度，不知最后元素，但是肯定知道最后元素的next元素一定为null，以此作为出口，从后向前一段一段的进行翻转

### 0609归并两个有序链表

解题思路：

1、固定header，方便取合并后的链表

2、再添加一个执行header的next元素，比较两个链表的大小，取值最小的扔给next

3、当next指向的元素确定之后，要将l1或者l2移动到下一位

4、上述操作完成next元素基本确定，可以将next往下移动

5、对于最后在循环中没有操作完成的剩余部分，直接合并过来



### 0610 删除链表的第n个元素

解题思路：

 * 双重遍历法：先获取长度，然后再次遍历的时候将length-n个元素去掉即可

 * 单词遍历法：

   1、新增虚拟节点指向头（防止n=1时第一个元素删不掉，同样可以防止找不到当前链表的头）

   2、设置prev和next两指针都指向虚拟节点

   3、先移动next，让next和prev相距n的长度

   4、同时移动prev和next，知道next.next为空

### 0611链表奇偶元素聚集

链表按照奇偶元素聚集，要求算法空间复杂度为O(1)

数据特点是：奇元素与偶元素相邻，不允许开辟消耗大量内存的数据结构

解题思路：

 * 1、需要有两个变量来控制奇、偶表头，方便查找，还需要两个移动变量控制移动，元素还是使用之前链表的元素
 * 2、奇元素.next指向下一个偶元素，偶元素.next指向下一个奇元素
 * 3、当设置完奇元素和偶元素的时候，需要分别将它们的移动变量移动到下一个

### 0612 回文链表 1-2-3-2-1
 起初未仔细审题的时候以为只要扔到一个数组里面直接对比就完事儿，后来发现空间不能超过O(n)，将条件限制死了。
 如果是基本数据类型倒是可以格式化数据为字符串，然后翻转链表再格式化数据为字符串，两相对比就可以解决。
 后经过查证，最优答案为快慢指针，
 * 1、快指针是慢指针的2倍，快指针走完的时候，慢指针刚好在链表中间部分的附近。
 * 2、将前面或者后面的链表翻转，一对比就知道答案了