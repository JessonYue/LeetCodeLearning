> ```
> 实现 strStr() 函数。
> 
> 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
> 
> 示例 1:
> 
> 输入: haystack = "hello", needle = "ll"
> 输出: 2
> 示例 2:
> 
> 输入: haystack = "aaaaa", needle = "bba"
> 输出: -1
> 说明:
> 
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
> 
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
> ```

今天的算法很容易想到拿needle字符串去haystack字符串中逐个字符比较，假设haystack长度为n，needle长度为m，很明显算法时间复杂度为O(m*n)，空间复杂度为O(m+n)。

如果 haystack = {n个a}b，needle = {n-1个a}b，那么算法的比较次数将会是n*(n-1)次，但是实际上在第一次遇到不匹配的字符(第n-1个)的时候，前面的n-2个字符全都进行比较过，而每一轮却只能减少一个字符的比较，很浪费，就想着能多跳几个字符。  

1. haystack = aaaaba,needle = aaba

   很容易想到当比较到index = 2的时候发现haystack[2]!=needle=[2]，那下次比较的时候可以直接从haystack的第3个字符开始比较，马上就得出结果了。

2. haystack = abcabcabcd,needle = abcabcd

   这是1的一种反例，按照1的方式第一次遇到字符不匹配时，从haystack的第7个字符开始比较，那么将找不到子串，而实际上的index = 3，是可以找到子串。

基于以上分析，想了很久还是没有想出代码实现，最后去leetcode上面看了题解，题解中**RB算法**有些出乎意料，get到新技能，也比较简单。而和我自己想法相同的是**KMP算法**，理解起来很吃力，看了很多文章才看懂，下面对KMP算法做一些小结：

1、KMP算法在主串中的指针不会回退

2、KMP算法借助一个和子串一样长度的数组，该数组的获取方式时间复杂度为O(n)  

由1和2可得出KMP算法的时间复杂度为O(M),空间复杂度为O(N)

KMP算法的核心就是当遇到不匹配的字符时，从当前子串的字符前面的子串中找到一对最长的且相同的前缀子串和后缀子串，然后将**前缀子串移动到后缀子串的位置**，再循环进行比较。

有String s = "ABCD",则

**前缀子串**：“A”,"AB","ABC"。  

**后缀子串**："D","CD","BCD"



